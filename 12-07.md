# Домашнее задание к занятию «Репликация и масштабирование. Часть 2»

### Инструкция по выполнению домашнего задания

1. Сделайте fork [репозитория c шаблоном решения](https://github.com/netology-code/sys-pattern-homework) к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/gitlab-hw или https://github.com/имя-вашего-репозитория/8-03-hw).
2. Выполните клонирование этого репозитория к себе на ПК с помощью команды `git clone`.
3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
   - впишите вверху название занятия и ваши фамилию и имя;
   - в каждом задании добавьте решение в требуемом виде: текст/код/скриншоты/ссылка;
   - для корректного добавления скриншотов воспользуйтесь инструкцией [«Как вставить скриншот в шаблон с решением»](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md);
   - при оформлении используйте возможности языка разметки md. Коротко об этом можно посмотреть в [инструкции по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md).
4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`).
5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
6. Любые вопросы задавайте в чате учебной группы и/или в разделе «Вопросы по заданию» в личном кабинете.

Желаем успехов в выполнении домашнего задания.

---

### Задание 1

Опишите основные преимущества использования масштабирования методами:

- активный master-сервер и пассивный репликационный slave-сервер; 
- master-сервер и несколько slave-серверов;


*Дайте ответ в свободной форме.*

#### Решение 1

1. Основным преимуществом использования "активного master-сервера и пассивного репликационного slave-сервера" является обеспечение быстрого восстановления доступа к данным в случае выхода из строя Мастера за счет резервирования данныъ на slave-сервер.
2. Основным преимуществом использования "master-сервер и несколько slave-серверов" является как обеспечение быстрого восстановления доступа к данным в случае выхода из строя Мастера за счет резервирования данныъ на slave-сервер, так и снижение нагрузки на Мастер-сервер за счет настройки клиентов на чтение с slave-серверов.

---

### Задание 2


Разработайте план для выполнения горизонтального и вертикального шардинга базы данных. База данных состоит из трёх таблиц: 

- пользователи, 
- книги, 
- магазины (столбцы произвольно). 

Опишите принципы построения системы и их разграничение или разбивку между базами данных.

*Пришлите блоксхему, где и что будет располагаться. Опишите, в каких режимах будут работать сервера.* 

#### Решение 2
Исходные таблицы:

1. Пользоватлели:

```sql
users (
   - user_id SERIAL PRIMARY KEY,
   - login character varying not null,
   - password character varying not null,
   - name character varying not null,
   - middlename character varying not null,
   - lastname character varying not null,
   - dob date not null
)
```

2. Книги: 
```sql
books (
   - id bigint not null,
   - category_id int not null,
   - author character varying not null,
   - title character varying not null,
   - year int not null
   - pages int not null,
   - price bigint not null
)
```

3. Магазины:
```sql
shops(
   - id_shop bigint not null,
   - city_id bigint not null,
   - address character varying,
   - manager character varying not null
)
```

Таблицу **users** разделим с помощью вертикального шардирования на 2 шарда с целью отделения персональных данных в отдельный шард:

1. 
```sql
users_1 (
   - user_id bigint not null,
   - login TEXT NOT NULL,
   - password TEXT NOT NULL
)
```
2. 
```sql
users_2 (
   - user_id bigint not null,
   - name character varying not null,
   - middlename character varying not null,
   - lastname character varying not null,
   - dob date not null
)
```
Таблицу **books** разделим с помощью горизонтального шардирования на 3 шарда по категориям:

1. Категория до 3, включительно:
```sql
books (
   - id bigint not null,
   - category_id int not null,
   - CONSTRAINT category_id_check CHECK (category_id <= 3),
   - author character varying not null,
   - title character varying not null,
   - year int not null,
   - pages int not null,
   - price bigint not null
);
```
2. Категория от 3 до 6, включительно:
```sql
books (
   - id bigint not null,
   - category_id int not null,
   - CONSTRAINT category_id_check CHECK (category_id > 3 and category_id <= 6),
   - author character varying not null,
   - title character varying not null,
   - year int not null,
   - pages int not null,
   - price bigint not null
);
```
3. Категория более 6:
```sql
books (
   - id bigint not null,
   - category_id int not null,
   - CONSTRAINT category_id_check CHECK (category_id > 6),
   - author character varying not null,
   - title character varying not null,
   - year int not null,
   - pages int not null,
   - price bigint not null
);
```

Таблицу **shops** разделим с помощью горизонтального шардирования на 3 шарда по городам:

1. 
```sql
shops (
   - id_shop bigint not null,
   - CONSTRAINT city_id CHECK (city_id <= 5 ),
   - city_id bigint not null,
   - address character varying,
   - manager character varying not null
);
```

2. 
```sql
shops (
   - id_shop bigint not null,
   - CONSTRAINT city_id CHECK (city_id > 5 and city_id <= 10),
   - city_id bigint not null,
   - address character varying,
   - manager character varying not null
);
```

3. 
```sql
shops(
   - id_shop bigint not null,
   - CONSTRAINT city_id CHECK (city_id > 10 ),
   - city_id bigint not null,
   - address character varying,
   - manager character varying not null
);
```

---

## Дополнительные задания (со звёздочкой*)
Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.

---
### Задание 3*

Выполните настройку выбранных методов шардинга из задания 2.

*Пришлите конфиг Docker и SQL скрипт с командами для базы данных*.


#### Решение 3

#### docker-compose.yml:
```yml
version: '3.8'

services:
  postgres_b:
    image: postgres:latest
    container_name: "postgres_b"
    env_file: .env
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    ports:
      - "5632:5432"
    volumes:
      - ./db/shards.sql:/docker-entrypoint-initdb.d/start.sql
    networks:
       - postgres-network

  postgres_b1:
    image: postgres:latest
    container_name: "postgres_b1"
    env_file: .env
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    ports:
      - "5633:5432"
    volumes:
      - ./db_shard_1/shards.sql:/docker-entrypoint-initdb.d/start.sql
    networks:
       - postgres-network

  postgres_b2:
    image: postgres:latest
    container_name: "postgres_b2"
    env_file: .env
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    ports:
      - "5634:5432"
    volumes:
      - ./db_shard_2/shards.sql:/docker-entrypoint-initdb.d/start.sql
    networks:
       - postgres-network

  postgres_b3:
    image: postgres:latest
    container_name: "postgres_b3"
    env_file: .env
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    ports:
      - "5635:5432"
    volumes:
      - ./db_shard_3/shards.sql:/docker-entrypoint-initdb.d/start.sql
    networks:
       - postgres-network


networks:
  postgres-network:
  
```

#### ./db/shards.sql:
```sql
CREATE EXTENSION postgres_fdw;

/* SHARD 1 */
CREATE SERVER db_1_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'postgres_b1', port '5432', dbname 'pg_db');

CREATE USER MAPPING FOR "postgres"
    SERVER db_1_server
    OPTIONS (user 'postgres', password 'postgres');

CREATE FOREIGN TABLE books_1
(
    id bigint not null,
    category_id int not null,
    author character varying not null,
    title character varying not null,
    year int not null,
    pages int not null,
    price bigint not null
) SERVER db_1_server
  OPTIONS (schema_name 'public', table_name 'books');

CREATE FOREIGN TABLE users_1(
    user_id bigint not null,
    login TEXT NOT NULL,
    password TEXT NOT NULL
)SERVER db_1_server
  OPTIONS (schema_name 'public', table_name 'users');


CREATE FOREIGN TABLE shops_1
(
     id_shop bigint not null,
     city_id bigint not null,
     address character varying,
     manager character varying not null
) SERVER db_1_server
  OPTIONS (schema_name 'public', table_name 'shops');


/* SHARD 2 */
CREATE SERVER db_2_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'postgres_b2', port '5432', dbname 'pg_db');

CREATE USER MAPPING FOR "postgres"
    SERVER db_2_server
    OPTIONS (user 'postgres', password 'postgres');

CREATE FOREIGN TABLE books_2
(
    id bigint not null,
    category_id int not null,
    author character varying not null,
    title character varying not null,
    year int not null,
    pages int not null,
    price bigint not null
) SERVER db_2_server
  OPTIONS (schema_name 'public', table_name 'books');

CREATE FOREIGN TABLE users_2 (
    user_id bigint not null,
    name character varying not null,
    middlename character varying not null,
    lastname character varying not null,
    dob date not null
)SERVER db_2_server
  OPTIONS (schema_name 'public', table_name 'users');

CREATE FOREIGN TABLE shops_2
(
     id_shop bigint not null,
     city_id bigint not null,
     address character varying,
     manager character varying not null
) SERVER db_2_server
  OPTIONS (schema_name 'public', table_name 'shops');

/* SHARD 3 */
CREATE SERVER db_3_server
    FOREIGN DATA WRAPPER postgres_fdw
    OPTIONS (host 'postgres_b3', port '5432', dbname 'pg_db');

CREATE USER MAPPING FOR "postgres"
    SERVER db_3_server
    OPTIONS (user 'postgres', password 'postgres');

CREATE FOREIGN TABLE books_3
(
    id bigint not null,
    category_id int not null,
    author character varying not null,
    title character varying not null,
    year int not null, 
    pages int not null,
    price bigint not null
) SERVER db_3_server
  OPTIONS (schema_name 'public', table_name 'books');

CREATE FOREIGN TABLE shops_3
(
     id_shop bigint not null,
     city_id bigint not null,
     address character varying,
     manager character varying not null

) SERVER db_3_server
  OPTIONS (schema_name 'public', table_name 'shops');

CREATE VIEW books AS
SELECT *
FROM books_1
UNION ALL
SELECT *
FROM books_2
UNION ALL
SELECT *
FROM books_3;


CREATE VIEW shops AS
SELECT *
FROM shops_1
UNION ALL
SELECT *
FROM shops_2
UNION ALL
SELECT *
FROM shops_3;

CREATE RULE books_insert AS ON INSERT TO books
    DO INSTEAD NOTHING;
CREATE RULE books_update AS ON UPDATE TO books
    DO INSTEAD NOTHING;
CREATE RULE books_delete AS ON DELETE TO books
    DO INSTEAD NOTHING;

CREATE RULE shops_insert AS ON INSERT TO shops
    DO INSTEAD NOTHING;
CREATE RULE shops_update AS ON UPDATE TO shops
    DO INSTEAD NOTHING;
CREATE RULE shops_delete AS ON DELETE TO shops
    DO INSTEAD NOTHING;

CREATE RULE books_insert_to_1 AS ON INSERT TO books
    WHERE (category_id <= 3)
    DO INSTEAD INSERT INTO books_1
               VALUES (NEW.*);

CREATE RULE books_insert_to_2 AS ON INSERT TO books
    WHERE (category_id > 3 and category_id <= 6)
    DO INSTEAD INSERT INTO books_2
               VALUES (NEW.*);

CREATE RULE books_insert_to_3 AS ON INSERT TO books
    WHERE (category_id > 6)
    DO INSTEAD INSERT INTO books_3
               VALUES (NEW.*);



CREATE RULE shops_insert_to_1 AS ON INSERT TO shops
    WHERE (city_id <= 5)
    DO INSTEAD INSERT INTO shops_1
               VALUES (NEW.*);

CREATE RULE shops_insert_to_2 AS ON INSERT TO shops
    WHERE (city_id > 5 and city_id <= 10)
    DO INSTEAD INSERT INTO shops_2
               VALUES (NEW.*);

CREATE RULE shops_insert_to_3 AS ON INSERT TO shops
    WHERE (city_id > 10)
    DO INSTEAD INSERT INTO shops_3
               VALUES (NEW.*);
```
#### ./db_shard_1/shards.sql: 
```sql
CREATE TABLE books
(
    id bigint not null,
    category_id int not null,
    CONSTRAINT category_id_check CHECK (category_id <= 3),
    author character varying not null,
    title character varying not null,
    year int not null,
    pages int not null,
    price bigint not null
);

CREATE INDEX books_category_id_idx ON books USING btree(category_id);

CREATE TABLE users (
    user_id bigint not null,
    login TEXT NOT NULL,
    password TEXT  NOT NULL
);


CREATE TABLE shops
(   
   id_shop bigint not null,
   city_id bigint not null,
   CONSTRAINT city_id CHECK (city_id <= 5 ),
   address character varying,
   manager character varying not null
);

CREATE INDEX shops_city_id_idx ON shops USING btree(city_id);
```
#### ./db_shard_2/shards.sql: 
```sql
CREATE TABLE books
(
    id bigint not null,
    category_id int not null,
    CONSTRAINT category_id_check CHECK (category_id > 3 and category_id <= 6),
    author character varying not null,
    title character varying not null,
    year int not null,
    pages int not null,
    price bigint not null
);

CREATE INDEX books_category_id_idx ON books USING btree(category_id);

CREATE TABLE users (
    user_id bigint not null,
    name character varying not null,
    middlename character varying not null,
    lastname character varying not null,
    dob date not null
);

CREATE TABLE shops
(   
   id_shop bigint not null,
   city_id bigint not null,
   CONSTRAINT city_id CHECK (city_id > 5 and city_id <= 10),
   address character varying,
   manager character varying not null
);

CREATE INDEX shops_city_id_idx ON shops USING btree(city_id);

```
#### ./db_shard_3/shards.sql:
```sql
CREATE TABLE books
(
    id bigint not null,
    category_id int not null,
    CONSTRAINT category_id_check CHECK (category_id > 6),
    author character varying not null,
    title character varying not null,
    year int not null,
    pages int not null,
    price bigint not null
);

CREATE INDEX books_category_id_idx ON books USING btree(category_id);


CREATE TABLE shops
(   
   id_shop bigint not null,
   city_id bigint not null,
   CONSTRAINT city_id CHECK (city_id > 10 ),
   address character varying,
   manager character varying not null

);

CREATE INDEX shops_city_id_idx ON shops USING btree(city_id);
```
#### Вставка данных:

```sql
INSERT INTO books (id, category_id, author, title, year, pages, price)
VALUES (1, 1, 'Author1', 'book1', 1980, 1234,2234),
       (2, 2, 'Author2', 'book2', 1997, 1734,2332),
       (3, 5, 'Author3', 'book3', 2005, 234,2324),
       (4, 2, 'Author4', 'book4', 2005, 134,2356),
       (5, 7, 'Author5', 'book5', 2005, 124,786),
       (6, 5, 'Author6', 'book6', 2001, 123,333),
       (7, 9, 'Author7', 'book7', 1917, 1234,7689),
       (8, 2, 'Author8', 'book8', 1956, 1244,311),
       (9, 1, 'Author9', 'book9', 1972, 4234,245),
       (10, 8, 'Author10', 'book10', 1993, 1234,234);


INSERT INTO shops (id_shop, city_id, address,  manager)
VALUES (1, 1, 'Author1', 'book1'),
       (2, 1, 'Author2', 'book2'),
       (3, 2, 'Author3', 'book3'),
       (4, 6, 'Author4', 'book4'),
       (5, 11, 'Author5', 'book5'),
       (6, 22, 'Author6', 'book6'),
       (7, 2, 'Author7', 'book7'),
       (8, 3, 'Author8', 'book8'),
       (9, 8, 'Author9', 'book9'),
       (10, 8, 'Author10', 'book10');
    
```

![image1](https://github.com/hachubra/sdb-hw/blob/sdbsql-24/images/Screenshot_35.png)
![image1](https://github.com/hachubra/sdb-hw/blob/sdbsql-24/images/Screenshot_36.png)